# 敏捷编码

代码要清晰地表达意图。这样的代码清晰易懂，仅凭小聪明写出的程序很难维护。注释可以帮助理解，也可能导致不好的干扰，应该总是用代码沟通。

项目是以增量式方式进行开发的，写程序时也应该进行增量式编程。在编写代码的时候，要想保持简单很难做到——实际上，想写出简单的代码要远比写出令人厌恶的、过分复杂的代码难得多。

通过设计能够根据契约进行替换的系统，可以在不确定的未来中保持代码的灵活性。


### 代码要清晰地表达意图 
> 拒绝诱惑 
- 诱惑魔鬼：“可以工作而且易于理解的代码当然好，但是让人觉得聪明更加重要。别人给你钱是因为你脑子好使，让我们看看你到底有多聪明。” 
    - 开发代码时，应该更注重可读性，而不是只图自己方便。代码阅读的次数要远远超过编写的次数，所以在编写的时候值得花点功夫让它读起来更加简单。
- 守护天使：“要编写清晰的而不是讨巧的代码。向代码阅读者明确表明你的意图。可读性差的代码一点都不聪明。”
    - 从衡量标准上来看，代码清晰程度的优先级应该排在执行效率之前。 
    - 代码必须明确说出你的意图，而且必须富有表达力。这样可以让代码更易于被别人阅读和理解。代码不让人迷惑，也就减少了发生潜在错误的可能。一言以蔽之，代码应意图清晰，表达明确。 
    - 好的编码规范可以让代码变得易于理解，同时减少不必要的注释和文档。在编写代码时，应该使用语言特性来提升表现力。使用方法名来传达意向，对方法参数的命名要帮助读者理解背后的想法。异常传达的信息是哪些可能会出问题，以及如何进行防御式编程，要正确地使用和命名异常。 

> 切身感受：应该让自己或团队的其他任何人，可以读懂自己一年前写的代码，而且只读一遍就知道它的运行机制。

> 平衡艺术：
- 现在对你显而易见的事情，对别人可能并非如此，对于一年以后的你来说，也不一定显而易见。不妨将代码视作不知道会在未来何时打开的一个时间胶囊。   
- 不要明日复明日。如果现在不做的话，以后你也不会做的。
- 不要过分抽象。
- 使用符合当时情形的耦合。


### 用代码沟通 
> 拒绝诱惑 
- 诱惑魔鬼：“如果代码太杂乱以至于无法阅读，就应该使用注释来说明。精确地解释代码做了什么，每行代码都要加注释。不用管为什么要这样编码，只要告诉我们到底是怎么做的就好了。” 
    - 通常程序员都很讨厌写文档。这是因为大部分文档都与代码没有关系，并且越来越难以保证其符合目前的最新状况。这不只违反了DRY 原则，还会产生使人误解的文档，这还不如没有文档。
- 守护天使：“用注释沟通。使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。”
    - 建立代码文档无外乎两种方式：利用代码本身；利用注释来沟通代码之外的问题。
    - 如何界定一个良好的命名？良好的命名可以向读者传递大量的正确信息。不好的命名不会传递任何信息，糟糕的命名则会传递错误的信息。

> 切身感受：注释就像是可以帮助你的好朋友，可以先阅读注释，然后快速浏览代码，从而完全理解它做了什么，以及为什么这样做。

> 平衡艺术：
- 在代码可以传递意图的地方不要使用注释。   
- 解释代码做了什么的注释用处不那么大。相反，注释要说明为什么会这样写代码。


### 动态评估取舍
> 拒绝诱惑 
- 诱惑魔鬼：“性能、生产力、优雅、成本以及上市时间，在软件开发过程中都是至关重要的因素。每一项都必须达到最理想状态。” 
    - 对任何单个因素如此独断地强调，而不考虑它是否是项目成功的必要因素，必然导致灾难的发生。
- 守护天使：“动态评估权衡。考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。”
    - 没有适宜所有状况的最佳解决方案。你必须对手上的问题进行评估，并选出最合适的解决方案。每个设计都是针对特定问题的——只有明确地进行评估和权衡，才能得出更好的解决方案。

> 切身感受：即使不能面面俱到，你也应该觉得已经得到了最重要的东西——客户认为有价值的特性。

> 平衡艺术：
- 如果现在投入额外的资源和精力，是为了将来可能得到的好处，要确认投入一定要得到回报（大部分情况下，是不会有回报的）。   
- 过早的优化是万恶之源。   
- 不要事先预设结论，先看看现在是什么状况。


### 增量式编程
> 拒绝诱惑 
- 诱惑魔鬼：“真正的程序员写起代码来，一干就是几个小时，根本不停，甚至连头都不抬。不要停下来去编译你的代码，只要一直往下写就好了！” 
    - 可以使用测试优先开发方式，作为强制进行增量式编程的方式。关键在于持续做一些细小而有用的事情，而不是做一段长时间的编程或重构。
- 守护天使：“在很短的编辑/构建/测试循环中编写代码。这要比花费长时间仅仅做编写代码的工作好得多。可以创建更加清晰、简单、易于维护的代码。”
    - 增量式编程可以精炼并结构化你的代码。代码被复杂化、变成一团乱麻的几率减少了。所开发的代码基于即时的反馈，这些反馈来自以小步幅方式编写代码和测试的过程。
    - 采取增量式编程和测试，会倾向于创建更小的方法和更具内聚性的类。
    - 在编写代码的时候，要经常留心可以改进的微小方面。

> 切身感受：在写了几行代码之后，你会迫切地希望进行一次构建/测试循环。在没有得到反馈时，你不想走得太远。

> 平衡艺术：
- 在编译和测试运行中，停下来想一想，并暂时远离代码细节，这是保证不会偏离正确方向的好办法。  
- 要休息的话，就要好好休息。休息时请远离键盘。   
- 要像重构你的代码那样，重构你的测试，而且要经常重构测试


### 保持简单
> 拒绝诱惑 
- 诱惑魔鬼：“软件是很复杂的东西。随便哪个笨蛋都可以编写出简单、优雅的软件。通过编写史上最复杂的程序，你将会得到美誉和认可，更不用提保住你的工作了。” 
    - 相比一个过分复杂、拙劣的解决方案，简单的方案通常更难以获得。
- 守护天使：“开发可以工作的、最简单的解决方案。除非有不可辩驳的原因，否则不要使用模式、原则和高难度技术之类的东西。”
    - 要扪心自问，是不是真的需要用它，以及它将如何帮你解决眼前的问题。问问自己，是不是特定的问题强迫你使用这个解决方案。不要让自己被迫进行过分设计，也不要将代码过分复杂化。

> 切身感受：当你觉得所编写的代码中没有一行是多余的，并且仍能交付全部的功能时，这种感觉就对了。这样的代码容易理解和改正。

> 平衡艺术：
- 代码几乎总是可以得到进一步精炼，但是到了某个点之后，再做改进就不会带来任何实质性的好处了。这时开发人员就该停下来，去做其他方面的工作了。 



### 编写内聚的代码
> 拒绝诱惑 
- 诱惑魔鬼：“你要编写一些新的代码，首先要决定的就是把这些代码放在什么地方。其实放在什么地方问题不大，你就赶紧开始吧，看看IDE中现在打开的是哪个类，直接加进去就是了。如果所有的代码都在一个类或组件里面，要找起来是很方便的。” 
    - 相比一个过分复杂、拙劣的解决方案，简单的方案通常更难以获得。
- 守护天使：“让类的功能尽量集中，让组件尽量小。要避免创建很大的类或组件，也不要创建无所不包的大杂烩类。”
    - 要扪心自问，是不是真的需要用它，以及它将如何帮你解决眼前的问题。问问自己，是不是特定的问题强迫你使用这个解决方案。不要让自己被迫进行过分设计，也不要将代码过分复杂化。

> 切身感受：感觉类和组件的功能都很集中：每个类或组件只做一件事，而且做得很好。bug很容易跟踪，代码也易于修改，因为类和组件的责任都很清晰。

> 平衡艺术：
- 有可能会把一些东西拆分成很多微小的部分，而使其失去了实用价值。
- 具有良好内聚性的代码，可能会根据需求的变化，而成比例地进行变更。


### 告知，不要询问
> 拒绝诱惑 
- 诱惑魔鬼：“不要相信其他的对象。毕竟，它们是由别人写的，甚至有可能是你自己上个月头脑发昏的时候写的呢。从别人那里去拿你需要的信息，然后自己处理，自己决策。不要放弃控制别人的机会！”
    - 作为某段代码的调用者，开发人员绝对不应该基于被调用对象的状态来做出任何决策，更不能去改变该对象的状态。
- 守护天使：“告知，不要询问。不要抢别的对象或是组件的工作。告诉它做什么，然后盯着你自己的职责就好了。 ”
    - “面向过程的代码取得信息，然后做出决策。面向对象的代码让别的对象去做事情。”

> 切身感受：Smalltalk使用“信息传递”的概念，而不是方法调用。告知，不要询问感觉起来就像你在发送消息，而不是调用函数。

> 平衡艺术：
- 


### 根据契约进行替换
> 拒绝诱惑 
- 诱惑魔鬼：“深层次的继承是很棒的。如果你需要其他类的函数，直接继承它们就好了！不要担心你创建的新类会造成破坏，你的调用者可以改变他们的代码。这是他们的问题，而不是你的问题。” 
    - 继承是OO建模和编程中被滥用最多的概念之一。
    - 任何继承后得到的派生类对象，必须可以替换任何被使用的基类对象，而且使用者不必知道任何差异。
- 守护天使：“通过替换代码来扩展系统。通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。 ”
    - 如果新类可以替换已有的类，并且它们之间的关系可以通过is-a来描述，就要使用继承。   
    - 如果新类只是使用已有的类，并且两者之间的关系可以描述为has-a或是uses-a，就使用委托吧。

> 切身感受：这会让人觉得有点鬼鬼祟祟的，你可以偷偷地替换组件代码到代码库中，而且其他代码对此一无所知，它们还获得了新的或改进后的功能。

> 平衡艺术：
- 相对继承来说，委托更加灵活，适应力也更强。
- 如果你不确定一个接口做出了什么样的承诺，或是有什么样的需求，那就很难提供一个对其有意义的实现了。
